Вопрос №1:
При обговоренні змінних, які знаходяться в скоупі самого класу (змінні-поля), ми підкреслили, що вони мають бути “останнім засобом” для обміну даними в програмі. Майже завжди переважно використати параметри, які передаються у функцію і вертаються нею. Для кожної змінної в програмі поясніть, чому ви вибрали створити її не-локально (константи не вважаються змінними інстансу, тому не треба описувати константи тут).

Ответ:
1. Переменные GRect paddle, GOval ball, GLabel ifReady. Вынес их в глобальную переменную, так как обращаются к ним из разных методов. Например, к paddle я также обращаюсь в MouseMoved методе, а ball часто использует проверки на движение и столкновения. GLabel ifReady нужна, чтобы спросить у пользователя первое сообщение и потом удалить его через remove. Если использовать метод, то была ошибка и я не мог удалить надпись.

3. Переменная bricksLeft. Также использовал, как глобальную переменную, чтобы общраться к ней из разных методов. Например, при окончании игры или подсчете сколько кирпичей осталось, чтобы понять, победил пользователь или нет.

4. Переменная private vx, vy. Ну, во-первых, так сказано в условии, что ее надо вынести. Во вторых, также у vx изначально задается рандомной значение из другого метода.

Вопрос №2:
Гра закінчується або коли користувач втрачає три кулі, або коли уся цегла розбита. Як ви перевіряєте закінчення гри в цьому другому випадку? Чи робили ви зміни в коді при тестуванні?

1. Я создаю цикл for, в котором использую константу NTURNS, где объявляю, что пока переменная в цикле меньше этого значения, мы будем делать новую итерацию.
Логика самого цикла такая, что мы ждем клика, и показываем пользователю сообщение, после клика удаляем сообщение и запускаем метод startRounds с циклом.
startRounds запускает в себе цикл, который заставляет двигаться мячик и проходит разные проверки. В том числе и проверку ifLoseTry, ее логика такова, что если мячик опускается ниже значения getWidth, то я удаляю мячик и даю пользователю новую попытку. В этой проверке есть команда break, которая прерывает цикл while и запускает следующую итерацию цикла for. Соответственно, остается две попытки и по новой.

2. Проверка, если пользователь выиграл. Я считаю кол-во разбитых кирпчией. Это счетчик обновляется каждый раз, когда происходит команда remove(collider);.
Таким образом, когда счетчик будет равен 0, я делаю break, выхожу в основной цикл for и так делаю проверку, если победил true, прервать основной цикл.

3. Да, я делал изменения в коде при тестировании. У меня не получалось нормально прервать цикл, пока не обратил внимание, что помимо while, надо также прерывать и цикл for. Поэтому, когда я разбивал все кирпичи, программа ждала от меня еще два клика, так как кирпичи были полностью разбиты, то это было просто два клика, а не два раунда.